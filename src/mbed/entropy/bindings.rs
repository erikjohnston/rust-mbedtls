/* automatically generated by rust-bindgen */

pub type mbedtls_iso_c_forbids_empty_translation_units = ::libc::c_int;
pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
pub type int8_t = ::libc::c_char;
pub type int16_t = ::libc::c_short;
pub type int32_t = ::libc::c_int;
pub type int64_t = ::libc::c_long;
pub type uint8_t = ::libc::c_uchar;
pub type uint16_t = ::libc::c_ushort;
pub type uint32_t = ::libc::c_uint;
pub type uint64_t = ::libc::c_ulong;
pub type int_least8_t = ::libc::c_char;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_char;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intptr_t = ::libc::c_long;
pub type uintptr_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub total: [uint64_t; 2usize],
    pub state: [uint64_t; 8usize],
    pub buffer: [::libc::c_uchar; 128usize],
    pub is384: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mbedtls_sha512_context = Struct_Unnamed1;
pub type mbedtls_entropy_f_source_ptr =
    ::std::option::Option<extern "C" fn(data: *mut ::libc::c_void,
                                        output: *mut ::libc::c_uchar,
                                        len: size_t, olen: *mut size_t)
                              -> ::libc::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub f_source: mbedtls_entropy_f_source_ptr,
    pub p_source: *mut ::libc::c_void,
    pub size: size_t,
    pub threshold: size_t,
    pub strong: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mbedtls_entropy_source_state = Struct_Unnamed2;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub accumulator: mbedtls_sha512_context,
    pub source_count: ::libc::c_int,
    pub source: [mbedtls_entropy_source_state; 20usize],
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mbedtls_entropy_context = Struct_Unnamed3;
#[link(name = "mbedtls")]
#[link(name = "mbedx509")]
#[link(name = "mbedcrypto")]
extern "C" {
    pub fn mbedtls_sha512_init(ctx: *mut mbedtls_sha512_context) -> ();
    pub fn mbedtls_sha512_free(ctx: *mut mbedtls_sha512_context) -> ();
    pub fn mbedtls_sha512_clone(dst: *mut mbedtls_sha512_context,
                                src: *const mbedtls_sha512_context) -> ();
    pub fn mbedtls_sha512_starts(ctx: *mut mbedtls_sha512_context,
                                 is384: ::libc::c_int) -> ();
    pub fn mbedtls_sha512_update(ctx: *mut mbedtls_sha512_context,
                                 input: *const ::libc::c_uchar, ilen: size_t)
     -> ();
    pub fn mbedtls_sha512_finish(ctx: *mut mbedtls_sha512_context,
                                 output: *mut ::libc::c_uchar) -> ();
    pub fn mbedtls_sha512(input: *const ::libc::c_uchar, ilen: size_t,
                          output: *mut ::libc::c_uchar, is384: ::libc::c_int)
     -> ();
    pub fn mbedtls_sha512_self_test(verbose: ::libc::c_int) -> ::libc::c_int;
    pub fn mbedtls_sha512_process(ctx: *mut mbedtls_sha512_context,
                                  data: *mut ::libc::c_uchar) -> ();
    pub fn mbedtls_entropy_init(ctx: *mut mbedtls_entropy_context) -> ();
    pub fn mbedtls_entropy_free(ctx: *mut mbedtls_entropy_context) -> ();
    pub fn mbedtls_entropy_add_source(ctx: *mut mbedtls_entropy_context,
                                      f_source: mbedtls_entropy_f_source_ptr,
                                      p_source: *mut ::libc::c_void,
                                      threshold: size_t,
                                      strong: ::libc::c_int) -> ::libc::c_int;
    pub fn mbedtls_entropy_gather(ctx: *mut mbedtls_entropy_context)
     -> ::libc::c_int;
    pub fn mbedtls_entropy_func(data: *mut ::libc::c_void,
                                output: *mut ::libc::c_uchar, len: size_t)
     -> ::libc::c_int;
    pub fn mbedtls_entropy_update_manual(ctx: *mut mbedtls_entropy_context,
                                         data: *const ::libc::c_uchar,
                                         len: size_t) -> ::libc::c_int;
    pub fn mbedtls_entropy_write_seed_file(ctx: *mut mbedtls_entropy_context,
                                           path: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn mbedtls_entropy_update_seed_file(ctx: *mut mbedtls_entropy_context,
                                            path: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn mbedtls_entropy_self_test(verbose: ::libc::c_int) -> ::libc::c_int;
}
